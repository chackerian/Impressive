{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\n\nvar _window$document;\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { Platform } from '@unimodules/core';\nimport qs from 'qs';\nvar isDOMAvailable = Platform.OS === 'web' && typeof window !== 'undefined' && !!((_window$document = window.document) !== null && _window$document !== void 0 && _window$document.createElement) && typeof URL !== 'undefined';\nexport function requestAsync(_x, _x2) {\n  return _requestAsync.apply(this, arguments);\n}\n\nfunction _requestAsync() {\n  _requestAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(requestUrl, fetchRequest) {\n    var _fetchRequest$dataTyp;\n\n    var url, request, isJsonDataType, i, _fetchRequest$method, _i, _Object$keys, key, correctedUrl, response, contentType;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(Platform.OS === 'web' && !isDOMAvailable)) {\n              _context.next = 2;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 2:\n            url = new URL(requestUrl);\n            request = {\n              method: fetchRequest.method,\n              mode: 'cors',\n              headers: {}\n            };\n            isJsonDataType = ((_fetchRequest$dataTyp = fetchRequest.dataType) === null || _fetchRequest$dataTyp === void 0 ? void 0 : _fetchRequest$dataTyp.toLowerCase()) === 'json';\n\n            if (fetchRequest.headers) {\n              for (i in fetchRequest.headers) {\n                if (i in fetchRequest.headers) {\n                  request.headers[i] = fetchRequest.headers[i];\n                }\n              }\n            }\n\n            if (fetchRequest.body) {\n              if (((_fetchRequest$method = fetchRequest.method) === null || _fetchRequest$method === void 0 ? void 0 : _fetchRequest$method.toUpperCase()) === 'POST') {\n                request.body = qs.stringify(fetchRequest.body);\n              } else {\n                for (_i = 0, _Object$keys = Object.keys(fetchRequest.body); _i < _Object$keys.length; _i++) {\n                  key = _Object$keys[_i];\n                  url.searchParams.append(key, fetchRequest.body[key]);\n                }\n              }\n            }\n\n            if (isJsonDataType && !('Accept' in request.headers)) {\n              request.headers['Accept'] = 'application/json, text/javascript; q=0.01';\n            }\n\n            correctedUrl = url.toString().replace(/\\/$/, '');\n            _context.next = 11;\n            return fetch(correctedUrl, request);\n\n          case 11:\n            response = _context.sent;\n            contentType = response.headers.get('content-type');\n\n            if (!(isJsonDataType || contentType !== null && contentType !== void 0 && contentType.includes('application/json'))) {\n              _context.next = 15;\n              break;\n            }\n\n            return _context.abrupt(\"return\", response.json());\n\n          case 15:\n            return _context.abrupt(\"return\", response.text());\n\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _requestAsync.apply(this, arguments);\n}","map":{"version":3,"sources":["../src/Fetch.ts"],"names":[],"mappings":";;;;;AAAA,SAAS,QAAT,QAAyB,kBAAzB;AACA,OAAO,EAAP,MAAe,IAAf;AAgBA,IAAM,cAAc,GAClB,QAAQ,CAAC,EAAT,KAAgB,KAAhB,IACA,OAAO,MAAP,KAAkB,WADlB,IAEA,CAAC,sBAAC,MAAM,CAAC,QAAR,6CAAC,iBAAiB,aAAlB,CAFD,IAIA,OAAO,GAAP,KAAe,WALjB;AAOA,gBAAsB,YAAtB;AAAA;AAAA;;;6DAAO,iBAA+B,UAA/B,EAAmD,YAAnD;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,kBACD,QAAQ,CAAC,EAAT,KAAgB,KAAhB,IAAyB,CAAC,cADzB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAMC,YAAA,GAND,GAMO,IAAI,GAAJ,CAAQ,UAAR,CANP;AAQC,YAAA,OARD,GAQoE;AACvE,cAAA,MAAM,EAAE,YAAY,CAAC,MADkD;AAEvE,cAAA,IAAI,EAAE,MAFiE;AAGvE,cAAA,OAAO,EAAE;AAH8D,aARpE;AAcC,YAAA,cAdD,GAckB,0BAAA,YAAY,CAAC,QAAb,gFAAuB,WAAvB,QAAyC,MAd3D;;AAgBL,gBAAI,YAAY,CAAC,OAAjB,EAA0B;AACxB,mBAAW,CAAX,IAAgB,YAAY,CAAC,OAA7B,EAAsC;AACpC,oBAAI,CAAC,IAAI,YAAY,CAAC,OAAtB,EAA+B;AAC7B,kBAAA,OAAO,CAAC,OAAR,CAAgB,CAAhB,IAAqB,YAAY,CAAC,OAAb,CAAqB,CAArB,CAArB;AACD;AACF;AACF;;AAED,gBAAI,YAAY,CAAC,IAAjB,EAAuB;AACrB,kBAAI,yBAAA,YAAY,CAAC,MAAb,8EAAqB,WAArB,QAAuC,MAA3C,EAAmD;AACjD,gBAAA,OAAO,CAAC,IAAR,GAAe,EAAE,CAAC,SAAH,CAAa,YAAY,CAAC,IAA1B,CAAf;AACD,eAFD,MAEO;AACL,4CAAkB,MAAM,CAAC,IAAP,CAAY,YAAY,CAAC,IAAzB,CAAlB,kCAAkD;AAAvC,kBAAA,GAAuC;AAChD,kBAAA,GAAG,CAAC,YAAJ,CAAiB,MAAjB,CAAwB,GAAxB,EAA6B,YAAY,CAAC,IAAb,CAAkB,GAAlB,CAA7B;AACD;AACF;AACF;;AAED,gBAAI,cAAc,IAAI,EAAE,YAAY,OAAO,CAAC,OAAtB,CAAtB,EAAsD;AAEpD,cAAA,OAAO,CAAC,OAAR,CAAgB,QAAhB,IAA4B,2CAA5B;AACD;;AAGK,YAAA,YAxCD,GAwCgB,GAAG,CAAC,QAAJ,GAAe,OAAf,CAAuB,KAAvB,EAA8B,EAA9B,CAxChB;AAAA;AAAA,mBA0CkB,KAAK,CAAC,YAAD,EAAe,OAAf,CA1CvB;;AAAA;AA0CC,YAAA,QA1CD;AA4CC,YAAA,WA5CD,GA4Ce,QAAQ,CAAC,OAAT,CAAiB,GAAjB,CAAqB,cAArB,CA5Cf;;AAAA,kBA6CD,cAAc,IAAI,WAAJ,aAAI,WAAJ,eAAI,WAAW,CAAE,QAAb,CAAsB,kBAAtB,CA7CjB;AAAA;AAAA;AAAA;;AAAA,6CA8CI,QAAQ,CAAC,IAAT,EA9CJ;;AAAA;AAAA,6CAiDE,QAAQ,CAAC,IAAT,EAjDF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["import { Platform } from '@unimodules/core';\nimport qs from 'qs';\n\nexport type Headers = Record<string, string> & {\n  'Content-Type': string;\n  Authorization?: string;\n  Accept?: string;\n};\n\nexport type FetchRequest = {\n  headers?: Headers;\n  body?: Record<string, string>;\n  dataType?: string;\n  method?: string;\n};\n\n// TODO(Bacon): pending react-native-adapter publish after sdk 38\nconst isDOMAvailable =\n  Platform.OS === 'web' &&\n  typeof window !== 'undefined' &&\n  !!window.document?.createElement &&\n  // eslint-disable-next-line no-undef\n  typeof URL !== 'undefined';\n\nexport async function requestAsync<T>(requestUrl: string, fetchRequest: FetchRequest): Promise<T> {\n  if (Platform.OS === 'web' && !isDOMAvailable) {\n    // @ts-ignore\n    return;\n  }\n  // eslint-disable-next-line no-undef\n  const url = new URL(requestUrl);\n\n  const request: Omit<RequestInit, 'headers'> & { headers: HeadersInit } = {\n    method: fetchRequest.method,\n    mode: 'cors',\n    headers: {},\n  };\n\n  const isJsonDataType = fetchRequest.dataType?.toLowerCase() === 'json';\n\n  if (fetchRequest.headers) {\n    for (const i in fetchRequest.headers) {\n      if (i in fetchRequest.headers) {\n        request.headers[i] = fetchRequest.headers[i] as string;\n      }\n    }\n  }\n\n  if (fetchRequest.body) {\n    if (fetchRequest.method?.toUpperCase() === 'POST') {\n      request.body = qs.stringify(fetchRequest.body);\n    } else {\n      for (const key of Object.keys(fetchRequest.body)) {\n        url.searchParams.append(key, fetchRequest.body[key]);\n      }\n    }\n  }\n\n  if (isJsonDataType && !('Accept' in request.headers)) {\n    // NOTE: Github authentication will return XML if this includes the standard `*/*`\n    request.headers['Accept'] = 'application/json, text/javascript; q=0.01';\n  }\n\n  // Fix a problem with React Native `URL` causing a trailing slash to be added.\n  const correctedUrl = url.toString().replace(/\\/$/, '');\n\n  const response = await fetch(correctedUrl, request);\n\n  const contentType = response.headers.get('content-type');\n  if (isJsonDataType || contentType?.includes('application/json')) {\n    return response.json();\n  }\n  // @ts-ignore: Type 'string' is not assignable to type 'T'.\n  return response.text();\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}