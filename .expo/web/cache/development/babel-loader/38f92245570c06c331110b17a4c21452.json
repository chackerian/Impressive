{"ast":null,"code":"'use strict';\n\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport NativeEventEmitter from \"react-native-web/dist/exports/NativeEventEmitter\";\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport invariant from 'invariant';\nvar RNCPushNotificationIOS = NativeModules.RNCPushNotificationIOS;\nvar PushNotificationEmitter = new NativeEventEmitter(RNCPushNotificationIOS);\n\nvar _notifHandlers = new Map();\n\nvar DEVICE_NOTIF_EVENT = 'remoteNotificationReceived';\nvar NOTIF_REGISTER_EVENT = 'remoteNotificationsRegistered';\nvar NOTIF_REGISTRATION_ERROR_EVENT = 'remoteNotificationRegistrationError';\nvar DEVICE_LOCAL_NOTIF_EVENT = 'localNotificationReceived';\n\nvar PushNotificationIOS = function () {\n  function PushNotificationIOS(nativeNotif) {\n    var _this = this;\n\n    _classCallCheck(this, PushNotificationIOS);\n\n    _defineProperty(this, \"_data\", void 0);\n\n    _defineProperty(this, \"_alert\", void 0);\n\n    _defineProperty(this, \"_title\", void 0);\n\n    _defineProperty(this, \"_subtitle\", void 0);\n\n    _defineProperty(this, \"_sound\", void 0);\n\n    _defineProperty(this, \"_category\", void 0);\n\n    _defineProperty(this, \"_contentAvailable\", void 0);\n\n    _defineProperty(this, \"_badgeCount\", void 0);\n\n    _defineProperty(this, \"_notificationId\", void 0);\n\n    _defineProperty(this, \"_actionIdentifier\", void 0);\n\n    _defineProperty(this, \"_userText\", void 0);\n\n    _defineProperty(this, \"_isRemote\", void 0);\n\n    _defineProperty(this, \"_remoteNotificationCompleteCallbackCalled\", void 0);\n\n    _defineProperty(this, \"_threadID\", void 0);\n\n    _defineProperty(this, \"_fireDate\", void 0);\n\n    this._data = {};\n    this._remoteNotificationCompleteCallbackCalled = false;\n    this._isRemote = nativeNotif.remote;\n\n    if (this._isRemote) {\n      this._notificationId = nativeNotif.notificationId;\n    }\n\n    this._actionIdentifier = nativeNotif.actionIdentifier;\n    this._userText = nativeNotif.userText;\n\n    if (nativeNotif.remote) {\n      Object.keys(nativeNotif).forEach(function (notifKey) {\n        var notifVal = nativeNotif[notifKey];\n\n        if (notifKey === 'aps') {\n          _this._alert = notifVal.alert;\n          _this._title = notifVal === null || notifVal === void 0 ? void 0 : notifVal.alertTitle;\n          _this._subtitle = notifVal === null || notifVal === void 0 ? void 0 : notifVal.subtitle;\n          _this._sound = notifVal.sound;\n          _this._badgeCount = notifVal.badge;\n          _this._category = notifVal.category;\n          _this._contentAvailable = notifVal['content-available'];\n          _this._threadID = notifVal['thread-id'];\n          _this._fireDate = notifVal.fireDate;\n        } else {\n          _this._data[notifKey] = notifVal;\n        }\n      });\n    } else {\n      this._badgeCount = nativeNotif.badge || nativeNotif.applicationIconBadgeNumber;\n      this._sound = nativeNotif.sound || nativeNotif.soundName;\n      this._alert = nativeNotif.body;\n      this._title = nativeNotif === null || nativeNotif === void 0 ? void 0 : nativeNotif.title;\n      this._subtitle = nativeNotif === null || nativeNotif === void 0 ? void 0 : nativeNotif.subtitle;\n      this._threadID = nativeNotif['thread-id'];\n      this._data = nativeNotif.userInfo;\n      this._category = nativeNotif.category;\n      this._fireDate = nativeNotif.fireDate;\n    }\n  }\n\n  _createClass(PushNotificationIOS, [{\n    key: \"finish\",\n    value: function finish(fetchResult) {\n      if (!this._isRemote || !this._notificationId || this._remoteNotificationCompleteCallbackCalled) {\n        return;\n      }\n\n      this._remoteNotificationCompleteCallbackCalled = true;\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.onFinishRemoteNotification(this._notificationId, fetchResult);\n    }\n  }, {\n    key: \"getMessage\",\n    value: function getMessage() {\n      if (_typeof(this._alert) === 'object') {\n        var _this$_alert;\n\n        return (_this$_alert = this._alert) === null || _this$_alert === void 0 ? void 0 : _this$_alert.body;\n      }\n\n      return this._alert;\n    }\n  }, {\n    key: \"getSound\",\n    value: function getSound() {\n      return this._sound;\n    }\n  }, {\n    key: \"getCategory\",\n    value: function getCategory() {\n      return this._category;\n    }\n  }, {\n    key: \"getAlert\",\n    value: function getAlert() {\n      return this._alert;\n    }\n  }, {\n    key: \"getTitle\",\n    value: function getTitle() {\n      if (_typeof(this._alert) === 'object') {\n        var _this$_alert2;\n\n        return (_this$_alert2 = this._alert) === null || _this$_alert2 === void 0 ? void 0 : _this$_alert2.title;\n      }\n\n      return this._title;\n    }\n  }, {\n    key: \"getSubtitle\",\n    value: function getSubtitle() {\n      if (_typeof(this._alert) === 'object') {\n        var _this$_alert3;\n\n        return (_this$_alert3 = this._alert) === null || _this$_alert3 === void 0 ? void 0 : _this$_alert3.subtitle;\n      }\n\n      return this._subtitle;\n    }\n  }, {\n    key: \"getContentAvailable\",\n    value: function getContentAvailable() {\n      return this._contentAvailable;\n    }\n  }, {\n    key: \"getBadgeCount\",\n    value: function getBadgeCount() {\n      return this._badgeCount;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this._data;\n    }\n  }, {\n    key: \"getThreadID\",\n    value: function getThreadID() {\n      return this._threadID;\n    }\n  }, {\n    key: \"getActionIdentifier\",\n    value: function getActionIdentifier() {\n      return this._actionIdentifier;\n    }\n  }, {\n    key: \"getUserText\",\n    value: function getUserText() {\n      return this._userText;\n    }\n  }], [{\n    key: \"presentLocalNotification\",\n    value: function presentLocalNotification(details) {\n      RNCPushNotificationIOS.presentLocalNotification(details);\n    }\n  }, {\n    key: \"scheduleLocalNotification\",\n    value: function scheduleLocalNotification(details) {\n      RNCPushNotificationIOS.scheduleLocalNotification(details);\n    }\n  }, {\n    key: \"addNotificationRequest\",\n    value: function addNotificationRequest(request) {\n      var handledRequest = request.fireDate instanceof Date ? _objectSpread(_objectSpread({}, request), {}, {\n        fireDate: request.fireDate.toISOString()\n      }) : request;\n\n      var finalRequest = _objectSpread(_objectSpread({}, handledRequest), {}, {\n        repeatsComponent: request.repeatsComponent || {}\n      });\n\n      RNCPushNotificationIOS.addNotificationRequest(finalRequest);\n    }\n  }, {\n    key: \"setNotificationCategories\",\n    value: function setNotificationCategories(categories) {\n      RNCPushNotificationIOS.setNotificationCategories(categories);\n    }\n  }, {\n    key: \"cancelAllLocalNotifications\",\n    value: function cancelAllLocalNotifications() {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.cancelAllLocalNotifications();\n    }\n  }, {\n    key: \"removeAllPendingNotificationRequests\",\n    value: function removeAllPendingNotificationRequests() {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.removeAllPendingNotificationRequests();\n    }\n  }, {\n    key: \"removePendingNotificationRequests\",\n    value: function removePendingNotificationRequests(identifiers) {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.removePendingNotificationRequests(identifiers);\n    }\n  }, {\n    key: \"removeAllDeliveredNotifications\",\n    value: function removeAllDeliveredNotifications() {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.removeAllDeliveredNotifications();\n    }\n  }, {\n    key: \"getDeliveredNotifications\",\n    value: function getDeliveredNotifications(callback) {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.getDeliveredNotifications(callback);\n    }\n  }, {\n    key: \"removeDeliveredNotifications\",\n    value: function removeDeliveredNotifications(identifiers) {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.removeDeliveredNotifications(identifiers);\n    }\n  }, {\n    key: \"setApplicationIconBadgeNumber\",\n    value: function setApplicationIconBadgeNumber(number) {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.setApplicationIconBadgeNumber(number);\n    }\n  }, {\n    key: \"getApplicationIconBadgeNumber\",\n    value: function getApplicationIconBadgeNumber(callback) {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.getApplicationIconBadgeNumber(callback);\n    }\n  }, {\n    key: \"cancelLocalNotifications\",\n    value: function cancelLocalNotifications(userInfo) {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.cancelLocalNotifications(userInfo);\n    }\n  }, {\n    key: \"getScheduledLocalNotifications\",\n    value: function getScheduledLocalNotifications(callback) {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.getScheduledLocalNotifications(callback);\n    }\n  }, {\n    key: \"getPendingNotificationRequests\",\n    value: function getPendingNotificationRequests(callback) {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.getPendingNotificationRequests(callback);\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(type, handler) {\n      invariant(type === 'notification' || type === 'register' || type === 'registrationError' || type === 'localNotification', 'PushNotificationIOS only supports `notification`, `register`, `registrationError`, and `localNotification` events');\n      var listener;\n\n      if (type === 'notification') {\n        listener = PushNotificationEmitter.addListener(DEVICE_NOTIF_EVENT, function (notifData) {\n          handler(new PushNotificationIOS(notifData));\n        });\n      } else if (type === 'localNotification') {\n        listener = PushNotificationEmitter.addListener(DEVICE_LOCAL_NOTIF_EVENT, function (notifData) {\n          handler(new PushNotificationIOS(notifData));\n        });\n      } else if (type === 'register') {\n        listener = PushNotificationEmitter.addListener(NOTIF_REGISTER_EVENT, function (registrationInfo) {\n          handler(registrationInfo.deviceToken);\n        });\n      } else if (type === 'registrationError') {\n        listener = PushNotificationEmitter.addListener(NOTIF_REGISTRATION_ERROR_EVENT, function (errorInfo) {\n          handler(errorInfo);\n        });\n      }\n\n      _notifHandlers.set(type, listener);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type) {\n      invariant(type === 'notification' || type === 'register' || type === 'registrationError' || type === 'localNotification', 'PushNotificationIOS only supports `notification`, `register`, `registrationError`, and `localNotification` events');\n\n      var listener = _notifHandlers.get(type);\n\n      if (!listener) {\n        return;\n      }\n\n      listener.remove();\n\n      _notifHandlers[\"delete\"](type);\n    }\n  }, {\n    key: \"requestPermissions\",\n    value: function requestPermissions(permissions) {\n      var requestedPermissions = {\n        alert: true,\n        badge: true,\n        sound: true\n      };\n\n      if (permissions) {\n        requestedPermissions = {\n          alert: !!permissions.alert,\n          badge: !!permissions.badge,\n          sound: !!permissions.sound,\n          critical: !!permissions.critical\n        };\n      }\n\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      return RNCPushNotificationIOS.requestPermissions(requestedPermissions);\n    }\n  }, {\n    key: \"abandonPermissions\",\n    value: function abandonPermissions() {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.abandonPermissions();\n    }\n  }, {\n    key: \"checkPermissions\",\n    value: function checkPermissions(callback) {\n      invariant(typeof callback === 'function', 'Must provide a valid callback');\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.checkPermissions(callback);\n    }\n  }, {\n    key: \"getInitialNotification\",\n    value: function getInitialNotification() {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      return RNCPushNotificationIOS.getInitialNotification().then(function (notification) {\n        return notification && new PushNotificationIOS(notification);\n      });\n    }\n  }]);\n\n  return PushNotificationIOS;\n}();\n\n_defineProperty(PushNotificationIOS, \"FetchResult\", {\n  NewData: 'UIBackgroundFetchResultNewData',\n  NoData: 'UIBackgroundFetchResultNoData',\n  ResultFailed: 'UIBackgroundFetchResultFailed'\n});\n\n_defineProperty(PushNotificationIOS, \"AuthorizationStatus\", {\n  UNAuthorizationStatusNotDetermined: 0,\n  UNAuthorizationStatusDenied: 1,\n  UNAuthorizationStatusAuthorized: 2,\n  UNAuthorizationStatusProvisional: 3\n});\n\nexport default PushNotificationIOS;","map":{"version":3,"sources":["/Users/nathanchackerian/Desktop/Impressive/node_modules/@react-native-community/push-notification-ios/js/index.js"],"names":["invariant","RNCPushNotificationIOS","NativeModules","PushNotificationEmitter","NativeEventEmitter","_notifHandlers","Map","DEVICE_NOTIF_EVENT","NOTIF_REGISTER_EVENT","NOTIF_REGISTRATION_ERROR_EVENT","DEVICE_LOCAL_NOTIF_EVENT","PushNotificationIOS","nativeNotif","_data","_remoteNotificationCompleteCallbackCalled","_isRemote","remote","_notificationId","notificationId","_actionIdentifier","actionIdentifier","_userText","userText","Object","keys","forEach","notifKey","notifVal","_alert","alert","_title","alertTitle","_subtitle","subtitle","_sound","sound","_badgeCount","badge","_category","category","_contentAvailable","_threadID","_fireDate","fireDate","applicationIconBadgeNumber","soundName","body","title","userInfo","fetchResult","onFinishRemoteNotification","details","presentLocalNotification","scheduleLocalNotification","request","handledRequest","Date","toISOString","finalRequest","repeatsComponent","addNotificationRequest","categories","setNotificationCategories","cancelAllLocalNotifications","removeAllPendingNotificationRequests","identifiers","removePendingNotificationRequests","removeAllDeliveredNotifications","callback","getDeliveredNotifications","removeDeliveredNotifications","number","setApplicationIconBadgeNumber","getApplicationIconBadgeNumber","cancelLocalNotifications","getScheduledLocalNotifications","getPendingNotificationRequests","type","handler","listener","addListener","notifData","registrationInfo","deviceToken","errorInfo","set","get","remove","permissions","requestedPermissions","critical","requestPermissions","abandonPermissions","checkPermissions","getInitialNotification","then","notification","NewData","NoData","ResultFailed","UNAuthorizationStatusNotDetermined","UNAuthorizationStatusDenied","UNAuthorizationStatusAuthorized","UNAuthorizationStatusProvisional"],"mappings":"AAUA;;;;;;;;;;;;;AAGA,OAAOA,SAAP,MAAsB,WAAtB;AAOA,IAAOC,sBAAP,GAAiCC,aAAjC,CAAOD,sBAAP;AAEA,IAAME,uBAAuB,GAAG,IAAIC,kBAAJ,CAAuBH,sBAAvB,CAAhC;;AAEA,IAAMI,cAAc,GAAG,IAAIC,GAAJ,EAAvB;;AAEA,IAAMC,kBAAkB,GAAG,4BAA3B;AACA,IAAMC,oBAAoB,GAAG,+BAA7B;AACA,IAAMC,8BAA8B,GAAG,qCAAvC;AACA,IAAMC,wBAAwB,GAAG,2BAAjC;;IA0DMC,mB;AAyXJ,+BAAYC,WAAZ,EAAiC;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAC/B,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,yCAAL,GAAiD,KAAjD;AACA,SAAKC,SAAL,GAAiBH,WAAW,CAACI,MAA7B;;AACA,QAAI,KAAKD,SAAT,EAAoB;AAClB,WAAKE,eAAL,GAAuBL,WAAW,CAACM,cAAnC;AACD;;AAED,SAAKC,iBAAL,GAAyBP,WAAW,CAACQ,gBAArC;AACA,SAAKC,SAAL,GAAiBT,WAAW,CAACU,QAA7B;;AACA,QAAIV,WAAW,CAACI,MAAhB,EAAwB;AAGtBO,MAAAA,MAAM,CAACC,IAAP,CAAYZ,WAAZ,EAAyBa,OAAzB,CAAiC,UAACC,QAAD,EAAc;AAC7C,YAAMC,QAAQ,GAAGf,WAAW,CAACc,QAAD,CAA5B;;AAEA,YAAIA,QAAQ,KAAK,KAAjB,EAAwB;AACtB,UAAA,KAAI,CAACE,MAAL,GAAcD,QAAQ,CAACE,KAAvB;AACA,UAAA,KAAI,CAACC,MAAL,GAAcH,QAAd,aAAcA,QAAd,uBAAcA,QAAQ,CAAEI,UAAxB;AACA,UAAA,KAAI,CAACC,SAAL,GAAiBL,QAAjB,aAAiBA,QAAjB,uBAAiBA,QAAQ,CAAEM,QAA3B;AACA,UAAA,KAAI,CAACC,MAAL,GAAcP,QAAQ,CAACQ,KAAvB;AACA,UAAA,KAAI,CAACC,WAAL,GAAmBT,QAAQ,CAACU,KAA5B;AACA,UAAA,KAAI,CAACC,SAAL,GAAiBX,QAAQ,CAACY,QAA1B;AACA,UAAA,KAAI,CAACC,iBAAL,GAAyBb,QAAQ,CAAC,mBAAD,CAAjC;AACA,UAAA,KAAI,CAACc,SAAL,GAAiBd,QAAQ,CAAC,WAAD,CAAzB;AACA,UAAA,KAAI,CAACe,SAAL,GAAiBf,QAAQ,CAACgB,QAA1B;AACD,SAVD,MAUO;AACL,UAAA,KAAI,CAAC9B,KAAL,CAAWa,QAAX,IAAuBC,QAAvB;AACD;AACF,OAhBD;AAiBD,KApBD,MAoBO;AAGL,WAAKS,WAAL,GACExB,WAAW,CAACyB,KAAZ,IAAqBzB,WAAW,CAACgC,0BADnC;AAGA,WAAKV,MAAL,GAActB,WAAW,CAACuB,KAAZ,IAAqBvB,WAAW,CAACiC,SAA/C;AACA,WAAKjB,MAAL,GAAchB,WAAW,CAACkC,IAA1B;AACA,WAAKhB,MAAL,GAAclB,WAAd,aAAcA,WAAd,uBAAcA,WAAW,CAAEmC,KAA3B;AACA,WAAKf,SAAL,GAAiBpB,WAAjB,aAAiBA,WAAjB,uBAAiBA,WAAW,CAAEqB,QAA9B;AACA,WAAKQ,SAAL,GAAiB7B,WAAW,CAAC,WAAD,CAA5B;AACA,WAAKC,KAAL,GAAaD,WAAW,CAACoC,QAAzB;AACA,WAAKV,SAAL,GAAiB1B,WAAW,CAAC2B,QAA7B;AACA,WAAKG,SAAL,GAAiB9B,WAAW,CAAC+B,QAA7B;AACD;AACF;;;;WAQD,gBAAOM,WAAP,EAA4B;AAC1B,UACE,CAAC,KAAKlC,SAAN,IACA,CAAC,KAAKE,eADN,IAEA,KAAKH,yCAHP,EAIE;AACA;AACD;;AACD,WAAKA,yCAAL,GAAiD,IAAjD;AAEAd,MAAAA,SAAS,CACPC,sBADO,EAEP,2CAFO,CAAT;AAIAA,MAAAA,sBAAsB,CAACiD,0BAAvB,CACE,KAAKjC,eADP,EAEEgC,WAFF;AAID;;;WAKD,sBAAgC;AAC9B,UAAI,QAAO,KAAKrB,MAAZ,MAAuB,QAA3B,EAAqC;AAAA;;AACnC,+BAAO,KAAKA,MAAZ,iDAAO,aAAakB,IAApB;AACD;;AACD,aAAO,KAAKlB,MAAZ;AACD;;;WAOD,oBAAoB;AAClB,aAAO,KAAKM,MAAZ;AACD;;;WAOD,uBAAuB;AACrB,aAAO,KAAKI,SAAZ;AACD;;;WAOD,oBAA8B;AAC5B,aAAO,KAAKV,MAAZ;AACD;;;WAMD,oBAA8B;AAC5B,UAAI,QAAO,KAAKA,MAAZ,MAAuB,QAA3B,EAAqC;AAAA;;AACnC,gCAAO,KAAKA,MAAZ,kDAAO,cAAamB,KAApB;AACD;;AACD,aAAO,KAAKjB,MAAZ;AACD;;;WAMD,uBAAiC;AAC/B,UAAI,QAAO,KAAKF,MAAZ,MAAuB,QAA3B,EAAqC;AAAA;;AACnC,gCAAO,KAAKA,MAAZ,kDAAO,cAAaK,QAApB;AACD;;AACD,aAAO,KAAKD,SAAZ;AACD;;;WAOD,+BAAwC;AACtC,aAAO,KAAKQ,iBAAZ;AACD;;;WAOD,yBAAyB;AACvB,aAAO,KAAKJ,WAAZ;AACD;;;WAOD,mBAAmB;AACjB,aAAO,KAAKvB,KAAZ;AACD;;;WAOD,uBAAuB;AACrB,aAAO,KAAK4B,SAAZ;AACD;;;WAKD,+BAA+B;AAC7B,aAAO,KAAKtB,iBAAZ;AACD;;;WAKD,uBAAuB;AACrB,aAAO,KAAKE,SAAZ;AACD;;;WArgBD,kCAAgC8B,OAAhC,EAAiD;AAC/ClD,MAAAA,sBAAsB,CAACmD,wBAAvB,CAAgDD,OAAhD;AACD;;;WAMD,mCAAiCA,OAAjC,EAAkD;AAChDlD,MAAAA,sBAAsB,CAACoD,yBAAvB,CAAiDF,OAAjD;AACD;;;WAMD,gCAA8BG,OAA9B,EAA4D;AAC1D,UAAMC,cAAc,GAClBD,OAAO,CAACX,QAAR,YAA4Ba,IAA5B,mCACQF,OADR;AACiBX,QAAAA,QAAQ,EAAEW,OAAO,CAACX,QAAR,CAAiBc,WAAjB;AAD3B,WAEIH,OAHN;;AAIA,UAAMI,YAAY,mCACbH,cADa;AAEhBI,QAAAA,gBAAgB,EAAEL,OAAO,CAACK,gBAAR,IAA4B;AAF9B,QAAlB;;AAKA1D,MAAAA,sBAAsB,CAAC2D,sBAAvB,CAA8CF,YAA9C;AACD;;;WAMD,mCAAiCG,UAAjC,EAAqE;AACnE5D,MAAAA,sBAAsB,CAAC6D,yBAAvB,CAAiDD,UAAjD;AACD;;;WAOD,uCAAqC;AACnC7D,MAAAA,SAAS,CACPC,sBADO,EAEP,2CAFO,CAAT;AAIAA,MAAAA,sBAAsB,CAAC8D,2BAAvB;AACD;;;WAKD,gDAA8C;AAC5C/D,MAAAA,SAAS,CACPC,sBADO,EAEP,2CAFO,CAAT;AAIAA,MAAAA,sBAAsB,CAAC+D,oCAAvB;AACD;;;WAKD,2CAAyCC,WAAzC,EAAgE;AAC9DjE,MAAAA,SAAS,CACPC,sBADO,EAEP,2CAFO,CAAT;AAIAA,MAAAA,sBAAsB,CAACiE,iCAAvB,CAAyDD,WAAzD;AACD;;;WAOD,2CAA+C;AAC7CjE,MAAAA,SAAS,CACPC,sBADO,EAEP,2CAFO,CAAT;AAIAA,MAAAA,sBAAsB,CAACkE,+BAAvB;AACD;;;WAOD,mCACEC,QADF,EAEQ;AACNpE,MAAAA,SAAS,CACPC,sBADO,EAEP,2CAFO,CAAT;AAIAA,MAAAA,sBAAsB,CAACoE,yBAAvB,CAAiDD,QAAjD;AACD;;;WAOD,sCAAoCH,WAApC,EAAsE;AACpEjE,MAAAA,SAAS,CACPC,sBADO,EAEP,2CAFO,CAAT;AAIAA,MAAAA,sBAAsB,CAACqE,4BAAvB,CAAoDL,WAApD;AACD;;;WAOD,uCAAqCM,MAArC,EAAqD;AACnDvE,MAAAA,SAAS,CACPC,sBADO,EAEP,2CAFO,CAAT;AAIAA,MAAAA,sBAAsB,CAACuE,6BAAvB,CAAqDD,MAArD;AACD;;;WAOD,uCAAqCH,QAArC,EAAyD;AACvDpE,MAAAA,SAAS,CACPC,sBADO,EAEP,2CAFO,CAAT;AAIAA,MAAAA,sBAAsB,CAACwE,6BAAvB,CAAqDL,QAArD;AACD;;;WAOD,kCAAgCpB,QAAhC,EAAkD;AAChDhD,MAAAA,SAAS,CACPC,sBADO,EAEP,2CAFO,CAAT;AAIAA,MAAAA,sBAAsB,CAACyE,wBAAvB,CAAgD1B,QAAhD;AACD;;;WAMD,wCAAsCoB,QAAtC,EAA0D;AACxDpE,MAAAA,SAAS,CACPC,sBADO,EAEP,2CAFO,CAAT;AAIAA,MAAAA,sBAAsB,CAAC0E,8BAAvB,CAAsDP,QAAtD;AACD;;;WAKD,wCACEA,QADF,EAEE;AACApE,MAAAA,SAAS,CACPC,sBADO,EAEP,2CAFO,CAAT;AAIAA,MAAAA,sBAAsB,CAAC2E,8BAAvB,CAAsDR,QAAtD;AACD;;;WAQD,0BAAwBS,IAAxB,EAAyDC,OAAzD,EAA4E;AAC1E9E,MAAAA,SAAS,CACP6E,IAAI,KAAK,cAAT,IACEA,IAAI,KAAK,UADX,IAEEA,IAAI,KAAK,mBAFX,IAGEA,IAAI,KAAK,mBAJJ,EAKP,mHALO,CAAT;AAOA,UAAIE,QAAJ;;AACA,UAAIF,IAAI,KAAK,cAAb,EAA6B;AAC3BE,QAAAA,QAAQ,GAAG5E,uBAAuB,CAAC6E,WAAxB,CACTzE,kBADS,EAET,UAAC0E,SAAD,EAAe;AACbH,UAAAA,OAAO,CAAC,IAAInE,mBAAJ,CAAwBsE,SAAxB,CAAD,CAAP;AACD,SAJQ,CAAX;AAMD,OAPD,MAOO,IAAIJ,IAAI,KAAK,mBAAb,EAAkC;AACvCE,QAAAA,QAAQ,GAAG5E,uBAAuB,CAAC6E,WAAxB,CACTtE,wBADS,EAET,UAACuE,SAAD,EAAe;AACbH,UAAAA,OAAO,CAAC,IAAInE,mBAAJ,CAAwBsE,SAAxB,CAAD,CAAP;AACD,SAJQ,CAAX;AAMD,OAPM,MAOA,IAAIJ,IAAI,KAAK,UAAb,EAAyB;AAC9BE,QAAAA,QAAQ,GAAG5E,uBAAuB,CAAC6E,WAAxB,CACTxE,oBADS,EAET,UAAC0E,gBAAD,EAAsB;AACpBJ,UAAAA,OAAO,CAACI,gBAAgB,CAACC,WAAlB,CAAP;AACD,SAJQ,CAAX;AAMD,OAPM,MAOA,IAAIN,IAAI,KAAK,mBAAb,EAAkC;AACvCE,QAAAA,QAAQ,GAAG5E,uBAAuB,CAAC6E,WAAxB,CACTvE,8BADS,EAET,UAAC2E,SAAD,EAAe;AACbN,UAAAA,OAAO,CAACM,SAAD,CAAP;AACD,SAJQ,CAAX;AAMD;;AACD/E,MAAAA,cAAc,CAACgF,GAAf,CAAmBR,IAAnB,EAAyBE,QAAzB;AACD;;;WAQD,6BAA2BF,IAA3B,EAA4D;AAC1D7E,MAAAA,SAAS,CACP6E,IAAI,KAAK,cAAT,IACEA,IAAI,KAAK,UADX,IAEEA,IAAI,KAAK,mBAFX,IAGEA,IAAI,KAAK,mBAJJ,EAKP,mHALO,CAAT;;AAOA,UAAME,QAAQ,GAAG1E,cAAc,CAACiF,GAAf,CAAmBT,IAAnB,CAAjB;;AACA,UAAI,CAACE,QAAL,EAAe;AACb;AACD;;AACDA,MAAAA,QAAQ,CAACQ,MAAT;;AACAlF,MAAAA,cAAc,UAAd,CAAsBwE,IAAtB;AACD;;;WAUD,4BAA0BW,WAA1B,EAUG;AACD,UAAIC,oBAAoB,GAAG;AACzB5D,QAAAA,KAAK,EAAE,IADkB;AAEzBQ,QAAAA,KAAK,EAAE,IAFkB;AAGzBF,QAAAA,KAAK,EAAE;AAHkB,OAA3B;;AAKA,UAAIqD,WAAJ,EAAiB;AACfC,QAAAA,oBAAoB,GAAG;AACrB5D,UAAAA,KAAK,EAAE,CAAC,CAAC2D,WAAW,CAAC3D,KADA;AAErBQ,UAAAA,KAAK,EAAE,CAAC,CAACmD,WAAW,CAACnD,KAFA;AAGrBF,UAAAA,KAAK,EAAE,CAAC,CAACqD,WAAW,CAACrD,KAHA;AAIrBuD,UAAAA,QAAQ,EAAE,CAAC,CAACF,WAAW,CAACE;AAJH,SAAvB;AAMD;;AACD1F,MAAAA,SAAS,CACPC,sBADO,EAEP,2CAFO,CAAT;AAIA,aAAOA,sBAAsB,CAAC0F,kBAAvB,CAA0CF,oBAA1C,CAAP;AACD;;;WAOD,8BAA4B;AAC1BzF,MAAAA,SAAS,CACPC,sBADO,EAEP,2CAFO,CAAT;AAIAA,MAAAA,sBAAsB,CAAC2F,kBAAvB;AACD;;;WAQD,0BAAwBxB,QAAxB,EAA4C;AAC1CpE,MAAAA,SAAS,CAAC,OAAOoE,QAAP,KAAoB,UAArB,EAAiC,+BAAjC,CAAT;AACApE,MAAAA,SAAS,CACPC,sBADO,EAEP,2CAFO,CAAT;AAIAA,MAAAA,sBAAsB,CAAC4F,gBAAvB,CAAwCzB,QAAxC;AACD;;;WAQD,kCAA+D;AAC7DpE,MAAAA,SAAS,CACPC,sBADO,EAEP,2CAFO,CAAT;AAIA,aAAOA,sBAAsB,CAAC6F,sBAAvB,GAAgDC,IAAhD,CACL,UAACC,YAAD,EAAkB;AAChB,eAAOA,YAAY,IAAI,IAAIrF,mBAAJ,CAAwBqF,YAAxB,CAAvB;AACD,OAHI,CAAP;AAKD;;;;;;gBAjXGrF,mB,iBAuB8B;AAChCsF,EAAAA,OAAO,EAAE,gCADuB;AAEhCC,EAAAA,MAAM,EAAE,+BAFwB;AAGhCC,EAAAA,YAAY,EAAE;AAHkB,C;;gBAvB9BxF,mB,yBA6B8C;AAChDyF,EAAAA,kCAAkC,EAAE,CADY;AAEhDC,EAAAA,2BAA2B,EAAE,CAFmB;AAGhDC,EAAAA,+BAA+B,EAAE,CAHe;AAIhDC,EAAAA,gCAAgC,EAAE;AAJc,C;;AAmhBpD,eAAe5F,mBAAf","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nimport {NativeEventEmitter, NativeModules} from 'react-native';\nimport invariant from 'invariant';\nimport type {\n  NotificationAlert,\n  NotificationRequest,\n  NotificationCategory,\n  NotificationAction,\n} from './types';\nconst {RNCPushNotificationIOS} = NativeModules;\n\nconst PushNotificationEmitter = new NativeEventEmitter(RNCPushNotificationIOS);\n\nconst _notifHandlers = new Map();\n\nconst DEVICE_NOTIF_EVENT = 'remoteNotificationReceived';\nconst NOTIF_REGISTER_EVENT = 'remoteNotificationsRegistered';\nconst NOTIF_REGISTRATION_ERROR_EVENT = 'remoteNotificationRegistrationError';\nconst DEVICE_LOCAL_NOTIF_EVENT = 'localNotificationReceived';\n\nexport type {\n  NotificationAlert,\n  NotificationRequest,\n  NotificationCategory,\n  NotificationAction,\n};\n\nexport type ContentAvailable = 1 | null | void;\n\nexport type FetchResult = {\n  NewData: string,\n  NoData: string,\n  ResultFailed: string,\n};\n\nexport type AuthorizationStatus = {\n  UNAuthorizationStatusNotDetermined: 0,\n  UNAuthorizationStatusDenied: 1,\n  UNAuthorizationStatusAuthorized: 2,\n  UNAuthorizationStatusProvisional: 3,\n};\n\n/**\n * An event emitted by PushNotificationIOS.\n */\nexport type PushNotificationEventName = $Keys<{\n  /**\n   * Fired when a remote notification is received. The handler will be invoked\n   * with an instance of `PushNotificationIOS`.\n   */\n  notification: string,\n  /**\n   * Fired when a local notification is received. The handler will be invoked\n   * with an instance of `PushNotificationIOS`.\n   */\n  localNotification: string,\n  /**\n   * Fired when the user registers for remote notifications. The handler will be\n   * invoked with a hex string representing the deviceToken.\n   */\n  register: string,\n  /**\n   * Fired when the user fails to register for remote notifications. Typically\n   * occurs when APNS is having issues, or the device is a simulator. The\n   * handler will be invoked with {message: string, code: number, details: any}.\n   */\n  registrationError: string,\n}>;\n\n/**\n *\n * Handle push notifications for your app, including permission handling and\n * icon badge number.\n *\n * See https://reactnative.dev/docs/pushnotificationios.html\n */\nclass PushNotificationIOS {\n  _data: Object;\n  _alert: string | NotificationAlert;\n  _title: string;\n  _subtitle: string;\n  _sound: string;\n  _category: string;\n  _contentAvailable: ContentAvailable;\n  _badgeCount: number;\n  _notificationId: string;\n  /**\n   * The id of action the user has taken taken.\n   */\n  _actionIdentifier: ?string;\n  /**\n   * The text user has input if user responded with a text action.\n   */\n  _userText: ?string;\n  _isRemote: boolean;\n  _remoteNotificationCompleteCallbackCalled: boolean;\n  _threadID: string;\n  _fireDate: string | Date;\n\n  static FetchResult: FetchResult = {\n    NewData: 'UIBackgroundFetchResultNewData',\n    NoData: 'UIBackgroundFetchResultNoData',\n    ResultFailed: 'UIBackgroundFetchResultFailed',\n  };\n\n  static AuthorizationStatus: AuthorizationStatus = {\n    UNAuthorizationStatusNotDetermined: 0,\n    UNAuthorizationStatusDenied: 1,\n    UNAuthorizationStatusAuthorized: 2,\n    UNAuthorizationStatusProvisional: 3,\n  };\n\n  /**\n   * Schedules the localNotification for immediate presentation.\n   * @deprecated use `addNotificationRequest` instead\n   */\n  static presentLocalNotification(details: Object) {\n    RNCPushNotificationIOS.presentLocalNotification(details);\n  }\n\n  /**\n   * Schedules the localNotification for future presentation.\n   * @deprecated use `addNotificationRequest` instead\n   */\n  static scheduleLocalNotification(details: Object) {\n    RNCPushNotificationIOS.scheduleLocalNotification(details);\n  }\n\n  /**\n   * Sends notificationRequest to notification center at specified firedate.\n   * Fires immediately if firedate is not set.\n   */\n  static addNotificationRequest(request: NotificationRequest) {\n    const handledRequest =\n      request.fireDate instanceof Date\n        ? {...request, fireDate: request.fireDate.toISOString()}\n        : request;\n    const finalRequest = {\n      ...handledRequest,\n      repeatsComponent: request.repeatsComponent || {},\n    };\n\n    RNCPushNotificationIOS.addNotificationRequest(finalRequest);\n  }\n\n  /**\n   * Sets notification category to notification center.\n   * Used to set specific actions for notifications that contains specified category\n   */\n  static setNotificationCategories(categories: NotificationCategory[]) {\n    RNCPushNotificationIOS.setNotificationCategories(categories);\n  }\n\n  /**\n   * Cancels all scheduled localNotifications.\n   * @deprecated use `removeAllPendingNotificationRequests` instead\n   * - This method is deprecated in iOS 10 and will be removed from future release\n   */\n  static cancelAllLocalNotifications() {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.cancelAllLocalNotifications();\n  }\n\n  /**\n   * Removes all pending notifications\n   */\n  static removeAllPendingNotificationRequests() {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.removeAllPendingNotificationRequests();\n  }\n\n  /**\n   * Removes pending notifications with given identifier strings.\n   */\n  static removePendingNotificationRequests(identifiers: string[]) {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.removePendingNotificationRequests(identifiers);\n  }\n\n  /**\n   * Remove all delivered notifications from Notification Center.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#removealldeliverednotifications\n   */\n  static removeAllDeliveredNotifications(): void {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.removeAllDeliveredNotifications();\n  }\n\n  /**\n   * Provides you with a list of the app’s notifications that are still displayed in Notification Center.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getdeliverednotifications\n   */\n  static getDeliveredNotifications(\n    callback: (notifications: Array<Object>) => void,\n  ): void {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.getDeliveredNotifications(callback);\n  }\n\n  /**\n   * Removes the specified notifications from Notification Center\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#removedeliverednotifications\n   */\n  static removeDeliveredNotifications(identifiers: Array<string>): void {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.removeDeliveredNotifications(identifiers);\n  }\n\n  /**\n   * Sets the badge number for the app icon on the home screen.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#setapplicationiconbadgenumber\n   */\n  static setApplicationIconBadgeNumber(number: number) {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.setApplicationIconBadgeNumber(number);\n  }\n\n  /**\n   * Gets the current badge number for the app icon on the home screen.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getapplicationiconbadgenumber\n   */\n  static getApplicationIconBadgeNumber(callback: Function) {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.getApplicationIconBadgeNumber(callback);\n  }\n\n  /**\n   * Cancel local notifications.\n   * @deprecated - use `removePendingNotifications`\n   * See https://reactnative.dev/docs/pushnotificationios.html#cancellocalnotification\n   */\n  static cancelLocalNotifications(userInfo: Object) {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.cancelLocalNotifications(userInfo);\n  }\n\n  /**\n   * Gets the local notifications that are currently scheduled.\n   * @deprecated - use `getPendingNotificationRequests`\n   */\n  static getScheduledLocalNotifications(callback: Function) {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.getScheduledLocalNotifications(callback);\n  }\n\n  /**\n   * Gets the pending local notification requests.\n   */\n  static getPendingNotificationRequests(\n    callback: (requests: NotificationRequest[]) => void,\n  ) {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.getPendingNotificationRequests(callback);\n  }\n\n  /**\n   * Attaches a listener to remote or local notification events while the app\n   * is running in the foreground or the background.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#addeventlistener\n   */\n  static addEventListener(type: PushNotificationEventName, handler: Function) {\n    invariant(\n      type === 'notification' ||\n        type === 'register' ||\n        type === 'registrationError' ||\n        type === 'localNotification',\n      'PushNotificationIOS only supports `notification`, `register`, `registrationError`, and `localNotification` events',\n    );\n    let listener;\n    if (type === 'notification') {\n      listener = PushNotificationEmitter.addListener(\n        DEVICE_NOTIF_EVENT,\n        (notifData) => {\n          handler(new PushNotificationIOS(notifData));\n        },\n      );\n    } else if (type === 'localNotification') {\n      listener = PushNotificationEmitter.addListener(\n        DEVICE_LOCAL_NOTIF_EVENT,\n        (notifData) => {\n          handler(new PushNotificationIOS(notifData));\n        },\n      );\n    } else if (type === 'register') {\n      listener = PushNotificationEmitter.addListener(\n        NOTIF_REGISTER_EVENT,\n        (registrationInfo) => {\n          handler(registrationInfo.deviceToken);\n        },\n      );\n    } else if (type === 'registrationError') {\n      listener = PushNotificationEmitter.addListener(\n        NOTIF_REGISTRATION_ERROR_EVENT,\n        (errorInfo) => {\n          handler(errorInfo);\n        },\n      );\n    }\n    _notifHandlers.set(type, listener);\n  }\n\n  /**\n   * Removes the event listener. Do this in `componentWillUnmount` to prevent\n   * memory leaks.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#removeeventlistener\n   */\n  static removeEventListener(type: PushNotificationEventName) {\n    invariant(\n      type === 'notification' ||\n        type === 'register' ||\n        type === 'registrationError' ||\n        type === 'localNotification',\n      'PushNotificationIOS only supports `notification`, `register`, `registrationError`, and `localNotification` events',\n    );\n    const listener = _notifHandlers.get(type);\n    if (!listener) {\n      return;\n    }\n    listener.remove();\n    _notifHandlers.delete(type);\n  }\n\n  /**\n   * Requests notification permissions from iOS, prompting the user's\n   * dialog box. By default, it will request all notification permissions, but\n   * a subset of these can be requested by passing a map of requested\n   * permissions.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#requestpermissions\n   */\n  static requestPermissions(permissions?: {\n    alert?: boolean,\n    badge?: boolean,\n    sound?: boolean,\n    critical?: boolean,\n  }): Promise<{\n    alert: boolean,\n    badge: boolean,\n    sound: boolean,\n    critical: boolean,\n  }> {\n    let requestedPermissions = {\n      alert: true,\n      badge: true,\n      sound: true,\n    };\n    if (permissions) {\n      requestedPermissions = {\n        alert: !!permissions.alert,\n        badge: !!permissions.badge,\n        sound: !!permissions.sound,\n        critical: !!permissions.critical,\n      };\n    }\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    return RNCPushNotificationIOS.requestPermissions(requestedPermissions);\n  }\n\n  /**\n   * Unregister for all remote notifications received via Apple Push Notification service.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#abandonpermissions\n   */\n  static abandonPermissions() {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.abandonPermissions();\n  }\n\n  /**\n   * See what push permissions are currently enabled. `callback` will be\n   * invoked with a `permissions` object.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#checkpermissions\n   */\n  static checkPermissions(callback: Function) {\n    invariant(typeof callback === 'function', 'Must provide a valid callback');\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.checkPermissions(callback);\n  }\n\n  /**\n   * This method returns a promise that resolves to either the notification\n   * object if the app was launched by a push notification, or `null` otherwise.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getinitialnotification\n   */\n  static getInitialNotification(): Promise<?PushNotificationIOS> {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    return RNCPushNotificationIOS.getInitialNotification().then(\n      (notification) => {\n        return notification && new PushNotificationIOS(notification);\n      },\n    );\n  }\n\n  /**\n   * You will never need to instantiate `PushNotificationIOS` yourself.\n   * Listening to the `notification` event and invoking\n   * `getInitialNotification` is sufficient\n   *\n   */\n  constructor(nativeNotif: Object) {\n    this._data = {};\n    this._remoteNotificationCompleteCallbackCalled = false;\n    this._isRemote = nativeNotif.remote;\n    if (this._isRemote) {\n      this._notificationId = nativeNotif.notificationId;\n    }\n\n    this._actionIdentifier = nativeNotif.actionIdentifier;\n    this._userText = nativeNotif.userText;\n    if (nativeNotif.remote) {\n      // Extract data from Apple's `aps` dict as defined:\n      // https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html\n      Object.keys(nativeNotif).forEach((notifKey) => {\n        const notifVal = nativeNotif[notifKey];\n\n        if (notifKey === 'aps') {\n          this._alert = notifVal.alert;\n          this._title = notifVal?.alertTitle;\n          this._subtitle = notifVal?.subtitle;\n          this._sound = notifVal.sound;\n          this._badgeCount = notifVal.badge;\n          this._category = notifVal.category;\n          this._contentAvailable = notifVal['content-available'];\n          this._threadID = notifVal['thread-id'];\n          this._fireDate = notifVal.fireDate;\n        } else {\n          this._data[notifKey] = notifVal;\n        }\n      });\n    } else {\n      // Local notifications aren't being sent down with `aps` dict.\n      // TODO: remove applicationIconBadgeNumber on next major version\n      this._badgeCount =\n        nativeNotif.badge || nativeNotif.applicationIconBadgeNumber;\n      // TODO: remove soundName on next major version\n      this._sound = nativeNotif.sound || nativeNotif.soundName;\n      this._alert = nativeNotif.body;\n      this._title = nativeNotif?.title;\n      this._subtitle = nativeNotif?.subtitle;\n      this._threadID = nativeNotif['thread-id'];\n      this._data = nativeNotif.userInfo;\n      this._category = nativeNotif.category;\n      this._fireDate = nativeNotif.fireDate;\n    }\n  }\n\n  /**\n   * This method is available for remote notifications that have been received via:\n   * `application:didReceiveRemoteNotification:fetchCompletionHandler:`\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#finish\n   */\n  finish(fetchResult: string) {\n    if (\n      !this._isRemote ||\n      !this._notificationId ||\n      this._remoteNotificationCompleteCallbackCalled\n    ) {\n      return;\n    }\n    this._remoteNotificationCompleteCallbackCalled = true;\n\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.onFinishRemoteNotification(\n      this._notificationId,\n      fetchResult,\n    );\n  }\n\n  /**\n   * An alias for `getAlert` to get the notification's main message string\n   */\n  getMessage(): ?string | ?Object {\n    if (typeof this._alert === 'object') {\n      return this._alert?.body;\n    }\n    return this._alert;\n  }\n\n  /**\n   * Gets the sound string from the `aps` object\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getsound\n   */\n  getSound(): ?string {\n    return this._sound;\n  }\n\n  /**\n   * Gets the category string from the `aps` object\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getcategory\n   */\n  getCategory(): ?string {\n    return this._category;\n  }\n\n  /**\n   * Gets the notification's main message from the `aps` object\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getalert\n   */\n  getAlert(): ?string | ?Object {\n    return this._alert;\n  }\n\n  /**\n   * Gets the notification's title from the `aps` object\n   *\n   */\n  getTitle(): ?string | ?Object {\n    if (typeof this._alert === 'object') {\n      return this._alert?.title;\n    }\n    return this._title;\n  }\n\n  /**\n   * Gets the notification's subtitle from the `aps` object\n   *\n   */\n  getSubtitle(): ?string | ?Object {\n    if (typeof this._alert === 'object') {\n      return this._alert?.subtitle;\n    }\n    return this._subtitle;\n  }\n\n  /**\n   * Gets the content-available number from the `aps` object\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getcontentavailable\n   */\n  getContentAvailable(): ContentAvailable {\n    return this._contentAvailable;\n  }\n\n  /**\n   * Gets the badge count number from the `aps` object\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getbadgecount\n   */\n  getBadgeCount(): ?number {\n    return this._badgeCount;\n  }\n\n  /**\n   * Gets the data object on the notif\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getdata\n   */\n  getData(): ?Object {\n    return this._data;\n  }\n\n  /**\n   * Gets the thread ID on the notif\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getthreadid\n   */\n  getThreadID(): ?string {\n    return this._threadID;\n  }\n\n  /**\n   * Get's the action id of the notification action user has taken.\n   */\n  getActionIdentifier(): ?string {\n    return this._actionIdentifier;\n  }\n\n  /**\n   * Gets the text user has inputed if user has taken the text action response.\n   */\n  getUserText(): ?string {\n    return this._userText;\n  }\n}\n\nexport default PushNotificationIOS;\n"]},"metadata":{},"sourceType":"module"}