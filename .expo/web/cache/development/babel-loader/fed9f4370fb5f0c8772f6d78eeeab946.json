{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport * as Crypto from 'expo-crypto';\nimport * as Random from 'expo-random';\nimport invariant from 'invariant';\nvar CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\nfunction getRandomValues(input) {\n  var output = input;\n  if (input.byteLength !== input.length) input = new Uint8Array(input.buffer);\n  var bytes = Random.getRandomBytes(input.length);\n\n  for (var i = 0; i < bytes.length; i++) {\n    input[i] = bytes[i];\n  }\n\n  return output;\n}\n\nfunction convertBufferToString(buffer) {\n  var state = [];\n\n  for (var i = 0; i < buffer.byteLength; i += 1) {\n    var index = buffer[i] % CHARSET.length;\n    state.push(CHARSET[index]);\n  }\n\n  return state.join('');\n}\n\nfunction convertToUrlSafeString(b64) {\n  return b64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nexport function generateRandom(size) {\n  var buffer = new Uint8Array(size);\n  getRandomValues(buffer);\n  return convertBufferToString(buffer);\n}\nexport function deriveChallengeAsync(_x) {\n  return _deriveChallengeAsync.apply(this, arguments);\n}\n\nfunction _deriveChallengeAsync() {\n  _deriveChallengeAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(code) {\n    var buffer;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            invariant(code.length > 42 && code.length < 129, 'Invalid code length for PKCE.');\n            _context.next = 3;\n            return Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, code, {\n              encoding: Crypto.CryptoEncoding.BASE64\n            });\n\n          case 3:\n            buffer = _context.sent;\n            return _context.abrupt(\"return\", convertToUrlSafeString(buffer));\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _deriveChallengeAsync.apply(this, arguments);\n}\n\nexport function buildCodeAsync() {\n  return _buildCodeAsync.apply(this, arguments);\n}\n\nfunction _buildCodeAsync() {\n  _buildCodeAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2() {\n    var size,\n        codeVerifier,\n        codeChallenge,\n        _args2 = arguments;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            size = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 128;\n            codeVerifier = generateRandom(size);\n            _context2.next = 4;\n            return deriveChallengeAsync(codeVerifier);\n\n          case 4:\n            codeChallenge = _context2.sent;\n            return _context2.abrupt(\"return\", {\n              codeVerifier: codeVerifier,\n              codeChallenge: codeChallenge\n            });\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _buildCodeAsync.apply(this, arguments);\n}\n\nexport function generateHexStringAsync(_x2) {\n  return _generateHexStringAsync.apply(this, arguments);\n}\n\nfunction _generateHexStringAsync() {\n  _generateHexStringAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(size) {\n    var value, buffer;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            value = generateRandom(size);\n            _context3.next = 3;\n            return Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, value, {\n              encoding: Crypto.CryptoEncoding.HEX\n            });\n\n          case 3:\n            buffer = _context3.sent;\n            return _context3.abrupt(\"return\", convertToUrlSafeString(buffer));\n\n          case 5:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _generateHexStringAsync.apply(this, arguments);\n}","map":{"version":3,"sources":["../src/PKCE.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Crypto from 'expo-crypto';\nimport * as Random from 'expo-random';\nimport invariant from 'invariant';\n\nconst CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\nfunction getRandomValues(input: Uint8Array): Uint8Array {\n  const output = input;\n  // Get access to the underlying raw bytes\n  if (input.byteLength !== input.length) input = new Uint8Array(input.buffer);\n\n  const bytes = Random.getRandomBytes(input.length);\n\n  for (let i = 0; i < bytes.length; i++) input[i] = bytes[i];\n\n  return output;\n}\n\nfunction convertBufferToString(buffer: Uint8Array): string {\n  const state: string[] = [];\n  for (let i = 0; i < buffer.byteLength; i += 1) {\n    const index = buffer[i] % CHARSET.length;\n    state.push(CHARSET[index]);\n  }\n  return state.join('');\n}\n\nfunction convertToUrlSafeString(b64: string): string {\n  return b64\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '');\n}\n\nexport function generateRandom(size: number): string {\n  const buffer = new Uint8Array(size);\n  getRandomValues(buffer);\n  return convertBufferToString(buffer);\n}\n\n/**\n * Proof key for Code Exchange by OAuth Public Clients (RFC 7636), Section 4.1\n * [Section 4.1](https://tools.ietf.org/html/rfc7636#section-4.1)\n */\nexport async function deriveChallengeAsync(code: string): Promise<string> {\n  // 43 is the minimum, and 128 is the maximum.\n  invariant(code.length > 42 && code.length < 129, 'Invalid code length for PKCE.');\n\n  const buffer = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, code, {\n    encoding: Crypto.CryptoEncoding.BASE64,\n  });\n  return convertToUrlSafeString(buffer);\n}\n\nexport async function buildCodeAsync(\n  size: number = 128\n): Promise<{ codeChallenge: string; codeVerifier: string }> {\n  // This method needs to be resolved like all other native methods.\n  const codeVerifier = generateRandom(size);\n  const codeChallenge = await deriveChallengeAsync(codeVerifier);\n\n  return { codeVerifier, codeChallenge };\n}\n\n/**\n * Digest a random string with hex encoding, useful for creating `nonce`s.\n */\nexport async function generateHexStringAsync(size: number): Promise<string> {\n  const value = generateRandom(size);\n  const buffer = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, value, {\n    encoding: Crypto.CryptoEncoding.HEX,\n  });\n  return convertToUrlSafeString(buffer);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}